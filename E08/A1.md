1a
```
(λxy.yx)((λx.xy)(λz.y))   % GV(λy.yx)={y},    FV((λx.xy)(λz.y))={y}
=>α
(λxy'.y'x)((λx.xy)(λz.y)) % GV(λy'.y'x)={y'}, FV((λx.xy)(λz.y))={y}
=>β
λy'.y'((λx.xy)(λz.y))     % GV(xy)={},        FV(λz.y)={y}
=>β
λy'.y'((λz.y)y)           % GV(y)={},         FV(y)={y}
=>β
λy'.y'y
```

1b
```Haskell
g
 :: Int -> Int -> Int
g x 0 = x 
g 0 y = g 1 (y-1)
g x y = g (g (x-1) y) (y-1)
```
In λ-Term
```
<G> =
(λgxy.
<ite> (<iszero> y)
  x
  (<ite> (<iszero> x)
   (g <1> (<pred> y))
   (g (g (<pred> x) y) (<pred> 1))
  )
)
```

1c
```
<F> = 
(λfxyz.<ite>(<iszero>(<sub>xy))
  (<add>z<4>)
  (fy(<mult>yz)(<add>xy))
)
```

Zuerst löst man die Abstraktion über dem Fixpunktkombinator auf
```
<Y> <F>  = (λh.((λy.h(yy))(λy.h(yy)))) <F>
=>β 
(λy.<F> (yy)) (λy.<F> (yy)) = t_F t_F
=>β
<Y>  (λy.<F> (yy))(λy.<F> (yy)) = <F>  (t_F t_F)
```

Nun kann man weiter den Term vereinfachen.
```
<F>(t_F t_F) <2><3><5>= 
(λfnxy.<ite>(<iszero> (<pred> n))
  (<add> x y)
  (f (<pred> n) (<mult> x n) (<add> y n))
)(t_F t_F) <2><3><5>
=>*β
(<ite>(<iszero> (<pred> <2>))
  (<add> <3> <5>)
  ((t_F t_F) (<pred> <2>) (<mult> <3> <2>) (<add> <5> <2>))
) 
=>*β
(<ite>(<false>)
  (<add> <3> <5>)
  (<F> (t_F t_F) <1> <6> <7>)
) 
=>*β
<F> (t_F t_F) <1> <6> <7> =
(λfnxy.<ite>(<iszero> (<pred> n))
  (<add> x y)
  (f (<pred> n) (<mult> x n) (<add> y n))
)(t_F t_F) <1><6><7>
=>*β
(<ite>(<iszero> (<pred> <1>))
  (<add> <6> <7>)
  ((t_F t_F) (<pred> <1>) (<mult> <6> <1>) (<add> <7> <1>))
) 
=>*β
(<ite> (<true>)
  <13>
  ((t_F t_F) (<pred> <1>) (<mult> <6> <1>) (<add> <7> <1>))
) 
=>*β
<13>
```